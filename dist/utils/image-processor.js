class ImageProcessor{static SUPPORTED_FORMATS=["image/jpeg","image/png","image/webp","image/gif"];static MAX_SIZE_MB=5;static MAX_SIZE_BYTES=1024*ImageProcessor.MAX_SIZE_MB*1024;static async validateAndProcess(e){if(!this.isValidFormat(e.type))throw new Error("INVALID_FORMAT");if(!this.isValidSize(e.size))throw new Error("IMAGE_TOO_LARGE");const t=await this.toBase64(e),a=await this.getImageDimensions(t);return{base64:t,type:e.type,size:e.size,name:e.name,width:a.width,height:a.height}}static isValidFormat(e){return this.SUPPORTED_FORMATS.includes(e)}static isValidSize(e){return e<=this.MAX_SIZE_BYTES}static toBase64(e){return new Promise((t,a)=>{const i=new FileReader;i.onload=()=>{t(i.result)},i.onerror=()=>{a(new Error("Failed to read file"))},i.readAsDataURL(e)})}static getImageDimensions(e){return new Promise((t,a)=>{const i=new Image;i.onload=()=>{t({width:i.width,height:i.height})},i.onerror=()=>{a(new Error("Failed to load image"))},i.src=e})}static async createPreview(e,t=200,a=200){const i=new Image;i.src=e,await i.decode();let r=i.width,s=i.height;if(r>t||s>a){const e=Math.min(t/r,a/s);r*=e,s*=e}const o=document.createElement("canvas");return o.width=r,o.height=s,o.getContext("2d").drawImage(i,0,0,r,s),o.toDataURL("image/jpeg",.8)}static isValidUrl(e){try{const t=new URL(e);return"http:"===t.protocol||"https:"===t.protocol}catch{return!1}}static formatFileSize(e){if(0===e)return"0 Bytes";const t=Math.floor(Math.log(e)/Math.log(1024));return Math.round(e/Math.pow(1024,t)*100)/100+" "+["Bytes","KB","MB","GB"][t]}static getErrorMessage(e){return{INVALID_FORMAT:"Unsupported format. Please use JPG, PNG, WEBP, or GIF.",IMAGE_TOO_LARGE:`Image size exceeds ${this.MAX_SIZE_MB}MB. Please choose a smaller image.`,INVALID_URL:"Invalid image URL. Please provide a valid HTTP or HTTPS URL.",LOAD_FAILED:"Failed to load image. Please try again."}[e]||"An error occurred while processing the image."}}"undefined"!=typeof module&&module.exports&&(module.exports=ImageProcessor);